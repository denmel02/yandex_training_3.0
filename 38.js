// На клеточном поле, размером NxM (2 ≤ N, M ≤ 250) сидит Q (0 ≤ Q ≤ 10000) блох в различных клетках. "Прием пищи" блохами возможен только в кормушке - одна из клеток поля, заранее известная. Блохи перемещаются по полю странным образом, а именно, прыжками, совпадающими с ходом обыкновенного шахматного коня. Длина пути каждой блохи до кормушки определяется как количество прыжков. Определить минимальное значение суммы длин путей блох до кормушки или, если собраться блохам у кормушки невозможно, то сообщить об этом. Сбор невозможен, если хотя бы одна из блох не может попасть к кормушке.

// Формат ввода
// В первой строке входного файла находится 5 чисел, разделенных пробелом: N, M, S, T, Q. N, M - размеры доски (отсчет начинается с 1); S, T - координаты клетки - кормушки (номер строки и столбца соответственно), Q - количество блох на доске. И далее Q строк по два числа - координаты каждой блохи.

// Формат вывода
// Содержит одно число - минимальное значение суммы длин путей или -1, если сбор невозможен.

// Пример 1

// Ввод
// 2 2 1 1 1
// 2 2

// Вывод
// -1

// Пример 2

// Ввод
// 4 4 1 1 16
// 1 1
// 1 2
// 1 3
// 1 4
// 2 1
// 2 2
// 2 3
// 2 4
// 3 1
// 3 2
// 3 3
// 3 4
// 4 1
// 4 2
// 4 3
// 4 4

// Вывод
// 42

// В неориентированном графе требуется найти длину минимального пути между двумя вершинами.

// Формат ввода
// Первым на вход поступает число N – количество вершин в графе (1 ≤ N ≤ 100). Затем записана матрица смежности (0 обозначает отсутствие ребра, 1 – наличие ребра). Далее задаются номера двух вершин – начальной и конечной.

// Формат вывода
// Выведите L – длину кратчайшего пути (количество ребер, которые нужно пройти).

// Если пути нет, нужно вывести -1.

// Пример 1

// Ввод
// 10
// 0 1 0 0 0 0 0 0 0 0
// 1 0 0 1 1 0 1 0 0 0
// 0 0 0 0 1 0 0 0 1 0
// 0 1 0 0 0 0 1 0 0 0
// 0 1 1 0 0 0 0 0 0 1
// 0 0 0 0 0 0 1 0 0 1
// 0 1 0 1 0 1 0 0 0 0
// 0 0 0 0 0 0 0 0 1 0
// 0 0 1 0 0 0 0 1 0 0
// 0 0 0 0 1 1 0 0 0 0
// 5 4

// Вывод
// 2

// Пример 2

// Ввод
// 5
// 0 1 0 0 1
// 1 0 1 0 0
// 0 1 0 0 0
// 0 0 0 0 0
// 1 0 0 0 0
// 3 5

// Вывод
// 3

const fs = require('fs');
const fileContent = fs.readFileSync("input.txt", "utf8");

const Queue = require('./dataStructure/Queue');

const parse = (str) => {
    const [ data, ...pointsStr ] = str.split('\n');
    const [n, m, s, t, q] = data.split(' ');
    const points = pointsStr.slice(0, +q).map((pointStr) => {
        const [i, j] = pointStr.split(' ');

        return { i: +i, j: +j };
    });

    return { n: +n, m: +m, s: +s, t: +t, points };
}

const getPoints = (n, m, i, j) => {
    return points = [
        { i: i + 2, j: j + 1 },
        { i: i + 1, j: j + 2 },
        { i: i - 1, j: j + 2 },
        { i: i - 2, j: j + 1 },
        { i: i - 2, j: j - 1 },
        { i: i - 1, j: j - 2 },
        { i: i + 1, j: j - 2 },
        { i: i + 2, j: j - 1 },
    ].filter((point) => point.i > 0 && point.i <= n && point.j > 0 && point.j <= m);
}

const wsd = ({n, m, s, t}) => {
    const queue = new Queue();
    const table = Array.from({ length: n + 1 }, () => []);

    table[s][t] = 0;

    queue.push({ i: s, j: t });

    while (queue.size) {
        const { i, j } = queue.pop();
        const nextDist = table[i][j] + 1;

        getPoints(n, m, i, j).forEach((point) => {
            const { i: nextI, j: nextJ } = point;

            if (table[nextI][nextJ] === undefined) {
                table[nextI][nextJ] = nextDist;
                queue.push(point);
            }
        })
    }

    return table;
}

const fn = (data) => {
    const { points } = data;
    const table = wsd(data);
    let sum = 0;

    for (let {i, j} of points) {
        const dist = table[i][j];

        if (dist === undefined) {
            return -1;
        }

        sum += dist;
    }

    return sum;
}

const data = parse(fileContent.toString());
const result = fn(data);

fs.writeFileSync("output.txt", result.toString())